<glider-container
    _="
       init
       js(me)
       const hover_glider_element = me.querySelector('active-glider') ?? null,
       glider_container_element = me ?? null;

       if (hover_glider_element == null || glider_container_element == null) {
       console.log('elements are null | skipping | `vercel-hover.js`');
       return;
       }

       let direction =
       glider_container_element.getAttribute('direction') ?? null,
       GLIDER_TRANSITION_DURATION =
       parseInt(glider_container_element.getAttribute('duration')) ||
       200,
       mouse_leave_timeout = null,
       is_hovered_from_prev_el = false;

       const handle_mouseenter = (event) => {
       const target = event.target;
       const target_computed_style = getComputedStyle(target);

       glider_container_element.style.position = 'relative';

       hover_glider_element.style.height =
       target_computed_style.height;
       hover_glider_element.style.width = target_computed_style.width;

       const target_zindex = parseInt(target_computed_style.zIndex);
       glider_container_element.style.zIndex = String(
       target_zindex ?? 0
       );
       hover_glider_element.style.zIndex = String(
       target_zindex - 1 ?? -1
       );

       switch (direction) {
       case 'vertical':
       hover_glider_element.style.transform = `translateY(${target.offsetTop}px)`;
       break;
       case 'horizontal':
       hover_glider_element.style.transform = `translateX(${target.offsetLeft}px)`;
       break;
       }

       if (is_hovered_from_prev_el) {
       GLIDER_TRANSITION_DURATION = 200;
       hover_glider_element.style.transitionDuration = `${GLIDER_TRANSITION_DURATION}ms`;
       } else {
       GLIDER_TRANSITION_DURATION = 50;
       hover_glider_element.style.transitionDuration = `${GLIDER_TRANSITION_DURATION}ms`;
       setTimeout(
       () => (hover_glider_element.style.opacity = '100'),
       GLIDER_TRANSITION_DURATION
       );
       is_hovered_from_prev_el = true;
       }

       clearTimeout(mouse_leave_timeout);
       },
       handle_mouseleave = () => {
       mouse_leave_timeout = setTimeout(() => {
       hover_glider_element.style.opacity = '0';
       is_hovered_from_prev_el = false;
       }, GLIDER_TRANSITION_DURATION);
       };

       Array.from(glider_container_element.children)
       .slice(1)
       .forEach((children) => {
       children.addEventListener('mouseenter', handle_mouseenter);
       children.addEventListener('mouseleave', handle_mouseleave);
       });

       end
      "
    class="{{ glider_container_class }}"
    direction="{{ direction }}"
    duration="{{ duration }}"
>
    <active-glider
        class="{{ active_element_class }} absolute opacity-0 ease-in-out duration-200"
    ></active-glider>
    {% slot 'items' default %} {% endslot %}
</glider-container>
